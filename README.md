## 1. Какой системный вызов делает команда cd?
```
chdir()
```

## 2. Попробуйте использовать команду file на объекты разных типов на файловой системе?
`openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`

## 3. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе)

1) По pid процесса, который держит файл, выяснить его дескрипторы.
2) В дескриптор отправить пустую строку, например, echo '' > /proc/123/fd/3


## 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Нет. Когда процесс завершается через exit, вся память и связанные с ним ресурсы освобождаются, чтобы их могли использовать другие процессы.

## 5. В iovisor BCC есть утилита opensnoop.
`dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
`
### На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.
```
PID    COMM               FD ERR PATH
1593   gsd-housekeepin    10   0 /etc/fstab
1593   gsd-housekeepin    10   0 /proc/self/mountinfo
1593   gsd-housekeepin    10   0 /run/mount/utab
1593   gsd-housekeepin    10   0 /proc/self/mountinfo
1593   gsd-housekeepin    10   0 /run/mount/utab
920    thermald            9   0 /sys/class/thermal/thermal_zone1/temp
1589   gsd-color          14   0 /etc/localtime
```

## 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
uname()
man uname(2) line 65:

Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.

## 7. Чем отличается последовательность команд через ; и через && в bash?
Операторы последовательного выполнения команд.
; выполнит все команды последовательно, даже если какая-то завершится ошибкой.
&& остановится при завершении какой-то команды в последовательности ошибкой.
С параметром -e оболочка завершится только при ненулевом коде возврата команды. Если ошибочно завершится одна из команд, разделённых &&, то выхода из шелла не произойдёт. Cмысл есть.

## 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
-e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности;
-x вывод трейса простых команд;
-u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и выполнит завершение не интерактивного вызова;
-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.
Повышает детализацию вывода ошибок и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды.

## 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
```
ps -Ao stat | sort | uniq -c | sort -h
      1 R+
      1 SNl
      1 S<s
      1 Ss+
      1 S<sl
      1 Ssl+
      1 STAT
      2 Sl+
      2 SN
      2 SNsl
      3 S+
     13 I
     15 S<
     21 Sl
     24 Ss
     49 I<
     54 Ssl
     57 S
```
S - процессы спящие, находятся в режиме ожидания
I - фоновые процессы ядра
